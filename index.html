<!doctype html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no,viewport-fit=cover" />
<title>反应测试</title>
<style>
  :root {
    font-family: system-ui, -apple-system, sans-serif;
    /* 定义背景变量，JS 只要改这个变量，全屏所有死角都会同步变色 */
    --current-bg: #d32f2f; 
  }

  /* 1. 暴力锁定：强制 html 和 body 覆盖整个物理屏幕，不准产生任何偏移 */
  html, body {
    height: 100%;
    width: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    position: fixed; /* 彻底锁死，防止添加到主屏幕后的系统橡皮筋回弹 */
    background-color: var(--current-bg);
  }

  /* 2. 暴力填充：让 screen 容器向外溢出 20%，确保无论 Safari 怎么算高度，它都填不满这个容器 */
  .screen {
    position: absolute;
    top: -10%; /* 向上溢出 */
    left: 0;
    right: 0;
    bottom: -10%; /* 向下溢出，彻底盖住所谓的“红条”区域 */
    
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    background-color: var(--current-bg);
    
    -webkit-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    transition: background-color 0.05s linear; /* 极速响应变色 */
    z-index: 1;
  }

  .text {
    font-size: 6.5vw; 
    line-height: 1.15;
    color: white;
    white-space: pre-line;
    /* 抵消上面 -10% 的偏移，让文字居中 */
    margin-top: 0; 
  }

  /* 3. 数据面板：适配 iPhone 底部安全区，防止被 Home 条挡住 */
  .data-panel {
    position: fixed;
    bottom: calc(20px + env(safe-area-inset-bottom));
    width: 46%;
    pointer-events: none;
    z-index: 10;
  }
  .left-panel { left: 10px; text-align: left; }
  .right-panel { right: 10px; text-align: right; }

  .list { display: flex; flex-direction: column-reverse; gap: 6px; }
  .item {
    font-size: 18px;
    color: rgba(255,255,255,0.95);
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
  }
  .item.current { color: #7CFC00; font-weight: bold; }
  .item.empty { color: rgba(255,255,255,0.4); }

  @media (max-width: 400px) { .item { font-size: 4.5vw; } }
</style>
</head>
<body>

<div id="screen" class="screen">
  <div id="text" class="text">正在初始化...</div>
</div>

<div class="data-panel left-panel">
  <div id="singles" class="list">
    <div class="item empty">—</div><div class="item empty">—</div><div class="item empty current">—</div>
  </div>
</div>

<div class="data-panel right-panel">
  <div id="avgs" class="list">
    <div class="item empty">—</div><div class="item empty">—</div><div class="item empty current">—</div>
  </div>
</div>

<script>
(function(){
  const screen = document.getElementById('screen');
  const textEl = document.getElementById('text');
  const singlesListEl = document.getElementById('singles');
  const avgListEl = document.getElementById('avgs');

  const COLORS = { RED: '#d32f2f', GREEN: '#2e7d32', BLUE: '#1976d2' };
  let state = 'idle', timeoutId = null, readyTs = 0;
  const results = [], batchAverages = [];
  let currentBatch = [];

  // 核心逻辑：同时修改变量和 body 背景，双重保险
  function setColor(col){
    document.documentElement.style.setProperty('--current-bg', col);
    document.body.style.backgroundColor = col; 
  }

  function setText(txt){ textEl.textContent = txt; }

  function toIdle(){
    clearPending();
    state = 'idle';
    setColor(COLORS.RED);
    setText('当屏幕变为绿色时点击屏幕\n点击即开始');
  }

  function clearPending(){
    if(timeoutId!==null){ clearTimeout(timeoutId); timeoutId = null; }
    readyTs = 0;
  }

  function startWaiting(){
    state = 'waiting';
    setColor(COLORS.RED);
    setText('等待中…\n请准备');
    const delay = 1000 + Math.floor(Math.random()*3000);
    timeoutId = setTimeout(() => {
      timeoutId = null;
      becomeReady();
    }, delay);
  }

  function becomeReady(){
    state = 'ready';
    setColor(COLORS.GREEN);
    readyTs = performance.now();
    setText('点击！');
  }

  function showResultMessage(msg){
    state = 'result';
    setColor(COLORS.BLUE);
    setText(msg + '\n\n点击屏幕重新开始');
  }

  function recordResult(ms) {
    results.push(ms);
    currentBatch.push(ms);
    if (currentBatch.length === 5) {
      const avg = Math.round(currentBatch.reduce((a,b)=>a+b,0) / 5);
      batchAverages.push(avg);
      currentBatch = [];
    }
    updateUI();
  }

  function updateUI() {
    const sItems = singlesListEl.querySelectorAll('.item');
    const aItems = avgListEl.querySelectorAll('.item');
    const lastThreeS = results.slice(-3);
    const lastThreeA = batchAverages.slice(-3);

    [sItems, aItems].forEach((items, idx) => {
      const data = idx === 0 ? lastThreeS : lastThreeA;
      for (let i = 0; i < 3; i++) {
        const val = data[data.length - 1 - i];
        items[i].textContent = val ? val + ' ms' : '—';
        items[i].classList.toggle('empty', !val);
        if (i === 0 && val) items[i].classList.add('current');
      }
    });
  }

  function handleAction(e){
    if(e) e.preventDefault();
    if(state === 'idle') { startWaiting(); }
    else if(state === 'waiting') { clearPending(); showResultMessage('太早了！'); }
    else if(state === 'ready') {
      const dt = Math.round(performance.now() - readyTs);
      showResultMessage('反应时间: ' + dt + ' ms');
      recordResult(dt);
    }
    else if(state === 'result') { startWaiting(); }
  }

  // 使用 pointerdown 确保响应速度最快
  screen.addEventListener('pointerdown', handleAction);
  
  // 彻底禁掉浏览器默认的拖拽回弹
  document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

  toIdle();
})();
</script>
</body>
</html>